## 纯数据存储
...

## 序列化

### 接口
* 快照（可选）
* delta更新（可选）
* 快照的使用
* delta更新的使用

### 实现
* 普通struct
    * bitwise快照
    * bitwise delta更新  
* 带反射复杂结构
    * 自动生成快照
    * 自动生成delta更新  
* 纯自定义手工代码

## 框架
### 全局一致
    正常使用数据模块
    如果有某数据，序列化时使用全局的预定义的序列化方式
### 多模板
    正常使用数据模块
    预先指定好自身模板
    使用模板预定义的序列化方式
### 个体自定义
    正常使用数据模块
    自身运行时注册自身的序列化方式

### 思考

纯数据存储模块  
网络模块遍历存储的数据，查是否有 网络相关需求  
网络设置可以全局一致，可以有多份模板，可以按个体不同？  


delta更新不好做的话，换一个思路
其实可以不用两个快照之间算diff
可以每一个操作都算一个delta
例如set，例如add
到时候正着施加操作，就得到下一个
回退操作，就得到之前的


纯数据截面自然好，不过类似   受击了显示从哪被攻击的，就不好做，因为没有攻击概念了，只剩下底层数据
可以从服务器被攻击时增加一个  单帧事件数据 从哪被攻击了，客户端看见了消费下


纯数据的话可以把entity和entity下属component都弄成同一个东西，可嵌套组合，类比json了
方便数据处理，可以直接以同一种方式遍历，diff，snapshot
但是这样就不好做那种 非纯数据的component


如果让纯数据就直接是个json这种的呢？
如何和运行时的需求结合在一起，比如weak ptr？


另外，之前想的 不同的使用方式写不同的archive，实现上可以让使用方式作为一个标记
可选是用默认的，还是区分，这样大部分默认，避免太麻烦



服务器维持兴趣列表，每次刷新时，记录客户端可见物，是一个数据结构
每次算出来不一样，可以做diff，把delta发给客户端
（不方便的地方在于，运行时数据，和同步的数据，要两套，diff也比较麻烦
    可以区分普通的直接覆盖数据和特殊需要处理的数据？
diff包含：
    添加删除entity（可划归到  添加删除项？）
    entity内部添加删除项
    每项内部数据变动（这个不太好想。。。））
每个component都包含多个切面（服务器运行时数据、服务器数据快照、客户端对数据快照的处理？）

好像也不对，还是直接两个entities比较，能处理对最好
这样最灵活，丢包、重连 等都方便处理





服务器把东西打包后，变成了一个DOM数据结构
可以对DOM做diff
得到 更新列表（增实体 删实体）
    更新列标项（增字段、删字段）
    再细化，应该能递归

客户端如何处理呢？
客户端得到DOM后，再反推回去客户端的entities view？
DOM的增删实体，对应entity增删
DOM的更新，施加到entity的数据上？